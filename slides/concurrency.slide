Concurrency

* Goroutines

Easily launch functions in a _goroutine_, similar to a light-weight thread.
.play ../src/sleep.go /^func main/,/^}/

Goroutines do not correspond 1:1 with threads on a machine. Each thread can have thousands of goroutines.

Execution is scheduled, and thread switching isn't necessary on an OS level.


* Channels

Channels are a convenient way to communicate between concurrently executing functions.

Channels define the direction of flow of values.

    a chan   int  // We can both read and write values to a
    b chan<- int  // We can only write to b
    c <-chan int  // We can only read from c

Since all parameters are passed by value, a goroutine will always reference the same channel.


* Finding the first N prime numbers

We will build a prime sieve to generate the first N prime numbers:

Begin by filling a channel with all integers >=2:
.code ../src/prime.go /^func fill/,/^}/

Filter out any numbers that we know are not prime and forward the rest to another channel:
.code ../src/prime.go /^func filter/,/^}/

* Putting it together

.play ../src/prime.go /^func main/,/^}/


* Visualising Concurrency

It is often difficult to visualize what is going on in concurrent applications.

Go lets you inject code before compilation and add extra function calls for output, and this can be helpful for generating visualisations for code.

[[https://divan.github.io/posts/go_concurrency_visualize/][divan.github.io]] - Trace function calls and output to a csv file. Render that in WebGL
[[http://divan.github.io/demos/primesieve/][Prime Sieve]]
