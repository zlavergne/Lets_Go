Error Handling

* Living Without Exceptions
Go does not have exceptions. Uses the error interface.

    type error interface {
        Error() string
    }

Any type that impliments a function that returns a string can be thought of, or used, as an error.

Because error is an interface, creating custom error types is easy, with as much or as little detail as needed. 

Because functions can return multiple values, at least one of the returned values are for errors.

Must do something with the error returned, using a variable or an underscore to intentionally ignore the error.

* Living Without Exceptions

    val, err = sqrt(-2)
The above would return a default value to val, and an error type to err.
Without an error, err will be equal to nil. So we would check for errors by comparing the returned err to nil.
    
    val, err := sqrt(-2) 
    if err != nil {
       // do error handling
    }
Can create custom error messages calling errors New method. 
.play ../src/handling.go /^func sqrtWithErrorReturn/,/^}/

* Living Without Exceptions

Some users may be frustrated by constantly error checking with Go, but that just means you must in some way handle the errors which requires thought and leads to solid, stable code.

* Handle It... Later
The defer statement pushes a function call onto a deferred stack. The list of saved calls is then executed at the end of the surrounding function.

Commonly this is used to simplify function clean up.

Deffered functions can read and assign to the functions return values.

.play ../src/defer.go /^func deferingAction/,/^}/

* Panic! 
Built in function stops the flow of the program and ... Panics.

If a function calls panic, the function stops, any deferred calls run, and the process goes up the call stack until all routines have returned and the program crashes.

* Aaand Recover.
Recovers from a panicking function.
  
Is only useful in deferred functions. 

Returns nil in non-panicking situations. 

